<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="parte1.css" />
    <link rel="icon" href="./img/picotre.jpg" type="image/x-icon" />
    <title>Parte2</title>
</head>

<body>
    <div class="all">
        <div class="preguntas">Creación de ramas. Recuerda que en la rama master/main sólo debería existir la versión acabada del producto.</div>
        <p>No podemos crear una nueva rama partida de la main sin tener ningún commit, 
            <br>aun así vamos a intentarlo para ver que pasa, vamos a crear un archivo readme.md pero no vamos a 
            <br>hacer no vamos a comitearlo y vamos a intentar hacer una rama para ver que nos sale</p>
            <div class="IntentoCommit"><img src="./img/Cap_intento_commit.png"></div>
            <p>Como vemos nos sale que no es valido y cuando hacemos un branch para ver las ramas que tenemos nos sale vacío 
                <br>esto es debido a que la rama main se crea después de hacer el primer commit</p>
            <div class="main"><img src="./img/main1.png"></div>
            <p>Aquí podemos ver que ahora si esta la rama main</p><br>
            <p>Ahora crearemos una nueva rama para trabajar en ella</p>
            <p>-git branch "nombre"</p>
            <div class="branch"><img src="./img/branch_prueba.png"></div>
            <p>Crearemos una segunda y añadiremos archivos</p>
            <div class="branch"><img src="./img/branch2.png"></div>

        <div class="preguntas">Proceso de merge entre ramas</div>
        <p>Uniremos la rama dev a la rama main</p>
        <p>Antes usaremos el git checkout para ir a la rama main</p>
        <p>Ahora escribiremos git merge y el nombre de la rama que queremos traer</p>
        <div class="merge"><img src="./img/Despuess_merge.png"></div>
        <p>Si hacemos un git log podremos ver que comparten los commits</p>
        <div class="log"><img src="./img/logDespues_merge.png"></div>    
        <p>Listo, ya tenemos actualizada la rama main</p>
        <p>Es igual para mergear cualquier otra rama, <br>
            en la rama main no debemos trabajar </p>   
        

<div class="preguntas"><h1>Resolución de conflictos en un merge</h1></div>
<div class="parte1">
    <p>
        Para ponernos en contexto, primero debemos saber que es un "merge".
        Ya sabemos que en un proyecto suelen trabajar varias personas, y concretamente con git, cada persona suele trabajar en su propia rama,
         pero varias personas pueden estar trabajando con un archivo en concrecto en sus respecticas ramas. Entonces... ¿qué pasa cuando queremos unir nuestras ramas?
    </p>
    <p>pues bien, el momento en el que fusionamos las ramas se llama "merge". Y si hay archivos que estan en diferentes ramas y modificados de diferente manera en la misma linea de códgio, 
        ,al querer hacer una fusión o "merge"  va a acabar en una serie de conflictos ya que en la misma linea de código, habrán cosas diferentes.</p>
        <p>a cotinuación vamos a mostrar los pasos para resolver estos conflictos:
        </p>
    <p>1. Nos metemos a la terminal Git</p>
    <p>2. Nos dirigimos al repositorio, que esta dando el conflicto de fusión</p>
    <p>3. En mi caso he creados dos Ramas una se llama StarPlatinum y la otra Dio</p>
    <h4>StarPlatinum</h4>
    <img src="./img/Creacionderama1.png" alt="Jotaro" height="150px">
    <h4>Dio</h4>
    <img src="./img/Creacionderama2.png" alt="Dio" height="150px">
    <h4>Fase cuatro intentar que tengan conflicto con los Stands.</h4>
    <img src="./img/meterloenblockparaconflicto.png" alt="Jotaro" height="200px">
    <img src="./img/Dioparaelblock.png" alt="Dio" height="200px">
    <h4>Ahora probaremos con el merge si Dio y Jotaro pueden convivir</h4>
    <img src="./img/PeleaJotaroDio.png" alt="J+D" height="200px">
    <h4>Abrimos el txt para ver que falla y vemos que Stand es</h4>
    <img src="./img/BlockConflicto.png" alt="Conflicto">
    <h4>Para arreglar este conflicto debemos, o borrar la linea de StarPlatinum, borrar la Dio o tambien que es lo que he hecho, combinar StarPlatinum con Dio. Quedara asi</h4>
    <img src="./img/CombinaciondeStans.png" alt="J+D">
    <h4>Actualizamos el archivo y hacemos un commit con un mensaje significativo. <3</h4>
    <img src="./img/FinaldePelea.png" alt="Dio">
    <h4>Asi hemos arreglado el conflicto del merge y ahora Jotaro no pelea con Dio porque Gano Dio</h4>


    <div class="preguntas"><h1>Diferencias entre un pull y un fetch.</h1></div>
        <p><strong>1. Debemos saber que tanto pull como fetch </Strong>se utilizan para actualizar la copia local de un repositorio remoto</p>
            <h2>Tabla de pull y fetch</h2>
            <table align="center">
                <tr>
                  <th style="border: 1px solid #ccc; padding: 5px;">Característica</th>
                  <th style="border: 1px solid #ccc; padding: 5px;">git fetch</th>
                  <th style="border: 1px solid #ccc; padding: 5px;">git pull</th>
                </tr>
                <tr>
                  <td style="border: 1px solid #ccc; padding: 5px;">Descarga cambios</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Sí</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Sí</td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ccc; padding: 5px;">Fusiona cambios</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">No</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Sí</td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ccc; padding: 5px;">Puede causar conflictos</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">No</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Sí</td>
                </tr>
                <tr>
                  <td style="border: 1px solid #ccc; padding: 5px;">Uso recomendado</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Si desea ver los cambios remotos sin fusionarlos</td>
                  <td style="border: 1px solid #ccc; padding: 5px;">Si desea fusionar los cambios remotos con su rama actual</td>
                </tr>
              </table>
    
              <div class="preguntas">
                <h1>¿Cómo podríamos volver a una versión anterior del proyecto?</h1>
                </div>
                <p> 
                    <p>Para esto, necesitariamos tener un archivo anteriormente creado y con al menos dos commits.</p>
                    <img src="./img/VolverAtras.png" alt="Commit inicial">
                    <img src="./img/GitHub.png" alt="Commits">
                    <br>
                    <p>Podemos recuperar el archivo (prueba.txt en los ejemplos siguientes) al estado en el que estaba antes de la modificación, es decir al estado en el que estaba en el último «commit» para eso utiliza el comando git checkout al último commit conocido que en este caso está en HEAD:
                    <br>
                    git checkout Prueba1(HEAD) Parte3 </p>
                    <img src="./img/paso01.png" alt="Paso01">
                    <br>
                   <p>Pero si esa versión no es buena, o si quieres volver el archivo en cuestión no a esa versión si no a una anterior en el tiempo, primero deberemos comprobar en el registro log de ese directorio de git los «commits» realizados para poder escoger a la versión que deseamos. Echamos un vistazo a los logs con este comando:
                   <br>
                    git log --oneline </p>
                    <img src="./img/Paso02.png" alt="Paso02">
                    <br>
                   <p>Lo que nos dará una salida «algo» similar a esta (con las lógicas diferencias de «commits», etc…)
                   <br>
                   4c8bde5 primer commit
                   <br>
                   59ff307 para volver a la anterior version
                   <br>
                   5ee9c18 segundo commit
                   <br>
                   6477aec Primer commit del proyecto. </p>
                   <br>
                   <p>Imaginemos que queremos devolver el archivo Parte3 a la versión como estaba en nuestro primer commit del proyecto. Para ello escribiremos el siguiente comando
                   <br>
                    git checkout 59ff307 Parte3 </p>
                    <img src="./img/Paso03.png" alt="Paso03">
                    <br>
                   <p>Ahora la versión antigua del archivo ha sido restaurada en el directorio de trabajoadir el archivo y volver a hacer un «commit» ya que el archivó cambió.
                   <br>
                   <br>
                   Puedes comprobar el estado del directorio de trabajo mediante el comando git status.
                   <img src="./img/Status.png" alt="Git status"> 
                   <br>
                   No olvides que una vez restaurado el archivo, es necesario volver a añadir el archivo y volver a hacer un «commit» ya que el archivó cambió.
                    git add Parte3
                    <br>
                    git commit -m "restaurar prueba.txt al estado del primer commit."" </p>
                    <img src="./img/Pasos05.png" alt="Pasos05">
                    <br>
                   <p>Comprobemos en el log de Git que efectivamente todo ha ido como queríamos:
                   <br>
                   git log --oneline
                   <br>
                   <img src="./img/Paso06.png" alt="Paso06">
                   <br>
                   nos saldra algo así:
                   <br>
                   6536889 restaurar Parte3 al estado del primer commit.
                   <br>
                   4c8bde5 commit prueba
                   <br>
                   5ee9c18 segundo commit
                   <br>
                   6477aec Primer commit del proyecto. </p>
                   <br>
                   <p>También podemos llevar no sólo un archivo a un punto predeterminado, si no todos los archivos del repositorio, para ello escribimos:
                   <br>
                   git checkout 6477aec
                   <img src="./img/PasoRapido.png" alt="Paso Rapido">
                   <br>
                   Al hacer esto, tu repositorio va atrás en el tiempo por completo, así que si ahora empiezas a trabajar sobre él podrías destruir tu futuro trabajo. Por defecto Git asume que no es eso lo que quieres hacer, así que separa donde se desarrolla el trabajo HEAD del proyecto y te deja empezar a trabajar.</p>
                </p>
                </div>
                <br>
            <div class="preguntas">
                <h1>¿Podemos añadir seguridad de alguna forma a nuestro repositorio remoto?</h1>
            </div>
                <p>Si, hay varias maneras de proteger tu repositorio remoto y todo su contenido.</p>
                <p><strong>1.Claves SSH:</strong> Si estás utilizando la autentización SSH, le puedes poner una contraseña a tu clave SSH.</p>
                <img src="./img/SSH.png" alt="Clave SSH">
                <br>
                <p><strong>2.Autentificación de Dos Factotes(2FA):</strong> Se tiene que agregar desde donde tienes tu repositorio. Esto lo que hace es que una vez ingreses tu contraseña, te pide un segundo método de reconocimiento al ingresar a tu cuenta.</p>
                <img src="./img/2FA.jpg" alt="Autentificación de Dos Factotes">
                <img src="./img/Verificacion.webp" alt="2FA">
                <br>
                <p><strong>3.Permisos y colaboradores:</strong> Tienes que ajustar los permisos de tu repositorio para que solo las personas que quieras tengan permisos de escritura y lectura.</p>
                <img src="./img/Permisos y colaboradores.png" alt="Permisos y colaboradores">
                <br>
                <p><strong>4.Auditoria y registros:</strong> Puedes revisar los registros de las actividades de cada usuario y así ver si a habido algun cambio raro.</p>
                <img src="./img/RegistroDeActividad.png" alt="Registro De Actividad">
                <br>
                <p><strong>5.Analisis de dependencias:</strong> Una de las partes más importantes es mantener las bibliotecas actualizadas. También puedes hacer análisis de seguridad para ver posibles vulnerabilidades.</p>
                <img src="./img/RegistroDeDependencias.webp" alt="Registro De Dependencias">
                <img src="./img/SecurityRisk.png" alt="Security Risk">
                <br>
                <p><strong>6.Escaneo de código:</strong> Puedes utilizar el análisis de código estático para ver vulnerabilidades en la estructura del código.</p>
                <img src="./img/EscaneoDeCodigo.webp" alt="EscaneoDeCodigo">
                <br>
                <p><strong>7.Politicas de contribución:</strong> Establece y comunica las políticas de contribución de tu proyecto. Esto garantiza que los colaboradores sigan estas políticas para mantener la integridad y seguridad del código.</p>
                <img src="./img/PoliticasDeContribución.png" alt="Politicas de contribución">
                <br>
                <p><strong>8.Actualizaciones de seguridad:</strong> Manten lo todo actualizado siempre que haya una actualización de seguridad de las herramientas y bibliotecas.</p>
                <img src="./img/Actualizacion.webp" alt="Actualizaciones de seguridad">

</div>
</body>
</html>